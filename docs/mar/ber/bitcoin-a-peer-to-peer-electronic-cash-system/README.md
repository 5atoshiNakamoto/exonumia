---
layout: RTLLayout
supporters: 
    - 
        name: "BitMEX"
        href: "https://blog.bitmex.com/bitmex-grant-translation-of-bitcoin-content-into-african-languages/"
translators: 
    - 
        name: "Ali Bourhime"
        email: "alif.bourhime@gmail.com"
---
# Bitcoin: نظام نقدي إلكتروني من نظير إلى نظير

بواسطة Satoshi Nakamoto [2008/10/31](/bitcoin.pdf)

<LanguageDropdown/>

## خلاصة

إن إصدار النقد الإلكتروني البحت من نظير إلى نظير من شأنه أن يسمح بإرسال المدفوعات عبر الإنترنت مباشرة من طرف إلى آخر دون المرور عبر مؤسسة مالية. توفر التوقيعات الرقمية جزءًا من الحل ، لكن الفوائد الرئيسية تضيع إذا كان هناك طرف ثالث موثوق به لا يزال مطلوبًا لمنع الإنفاق المزدوج. نقترح حلاً لمشكلة الإنفاق المزدوج باستخدام شبكة نظير إلى نظير. تقوم الشبكة بالطوابع الزمنية للمعاملات عن طريق تجزئتها في سلسلة مستمرة من إثبات العمل المستند إلى التجزئة ، وتشكيل سجل لا يمكن تغييره دون إعادة إثبات العمل. لا تعمل أطول سلسلة فقط كدليل على تسلسل الأحداث التي تمت مشاهدتها ، ولكنها دليل على أنها جاءت من أكبر تجمع لطاقة وحدة المعالجة المركزية. طالما يتم التحكم في غالبية طاقة وحدة المعالجة المركزية بواسطة العقد التي لا تتعاون لمهاجمة الشبكة ، فإنها ستولد أطول سلسلة وتتفوق على المهاجمين. تتطلب الشبكة نفسها الحد الأدنى من البنية. يتم بث الرسائل على أساس أفضل الجهود ، ويمكن للعقد أن تغادر وتعاود الانضمام إلى الشبكة كما تشاء ، وتقبل أطول سلسلة إثبات عمل كدليل على ما حدث أثناء ذهابها.

## مقدمة

أصبحت التجارة على الإنترنت تعتمد بشكل شبه حصري على المؤسسات المالية التي تعمل كأطراف ثالثة موثوق بها لمعالجة المدفوعات الإلكترونية. بينما يعمل النظام بشكل جيد بما يكفي لمعظم المعاملات ، فإنه لا يزال يعاني من نقاط الضعف الكامنة في النموذج القائم على الثقة. المعاملات غير القابلة للعكس تمامًا ليست ممكنة حقًا ، حيث لا يمكن للمؤسسات المالية تجنب التوسط في النزاعات. تزيد تكلفة الوساطة من تكاليف المعاملات ، مما يحد من الحد الأدنى لحجم المعاملات العملي ويقطع إمكانية المعاملات الصغيرة العرضية ، وهناك تكلفة أوسع في فقدان القدرة على إجراء مدفوعات غير قابلة للعكس للخدمات غير القابلة للعكس. مع إمكانية الانعكاس ، تنتشر الحاجة إلى الثقة. يجب أن يكون التجار حذرين من عملائهم ، مما يزعجهم للحصول على معلومات أكثر مما قد يحتاجون إليه بخلاف ذلك. يتم قبول نسبة معينة من الاحتيال على أنه أمر لا مفر منه. يمكن تجنب هذه التكاليف والشكوك المتعلقة بالدفع شخصيًا باستخدام العملة المادية ، ولكن لا توجد آلية لتسديد المدفوعات عبر قناة اتصالات بدون طرف موثوق به.

المطلوب هو نظام دفع إلكتروني يعتمد على إثبات التشفير بدلاً من الثقة ، مما يسمح لأي طرفين راغبين بالتعامل مباشرة مع بعضهما البعض دون الحاجة إلى طرف ثالث موثوق به. المعاملات التي لا يمكن عكسها عمليًا من الناحية الحسابية ستحمي البائعين من الاحتيال ، ويمكن بسهولة تنفيذ آليات الضمان الروتينية لحماية المشترين. في هذه الورقة ، نقترح حلاً لمشكلة الإنفاق المزدوج باستخدام خادم طابع زمني موزع من نظير إلى نظير لإنشاء إثبات حسابي للترتيب الزمني للمعاملات. النظام آمن طالما أن العقد الصادقة تتحكم بشكل جماعي في طاقة وحدة المعالجة المركزية أكثر من أي مجموعة متعاونة من عقد المهاجم.

## المعاملات

نحدد العملة الإلكترونية على أنها سلسلة من التوقيعات الرقمية. ينقل كل مالك العملة إلى التالي من خلال التوقيع رقميًا على تجزئة المعاملة السابقة والمفتاح العام للمالك التالي وإضافتهما إلى نهاية العملة المعدنية. يمكن للمدفوع له التحقق من التوقيعات للتحقق من سلسلة الملكية.

![](./transactions.svg)

المشكلة بالطبع هي أن المستفيد لا يمكنه التحقق من أن أحد المالكين لم ينفق العملة المعدنية مرتين. الحل الشائع هو تقديم سلطة مركزية موثوقة ، أو صك ، للتحقق من كل معاملة للإنفاق المزدوج. بعد كل معاملة ، يجب إعادة العملة إلى النعناع لإصدار عملة جديدة ، ولا يُوثق سوى العملات المعدنية الصادرة مباشرة من النعناع لن يتم إنفاقها مرتين. تكمن مشكلة هذا الحل في أن مصير نظام الأموال بأكمله يعتمد على الشركة التي تدير سك العملة ، حيث يجب أن تمر كل معاملة من خلالها ، تمامًا مثل البنك.

نحتاج إلى طريقة تمكن المستفيد من معرفة أن المالكين السابقين لم يوقعوا على أي معاملات سابقة. لأغراضنا ، فإن المعاملة الأولى هي التي تهم ، لذلك لا نهتم بالمحاولات اللاحقة لمضاعفة الإنفاق. الطريقة الوحيدة لتأكيد عدم وجود معاملة هي أن تكون على دراية بجميع المعاملات. في النموذج المعتمد على النعناع ، كان دار سك العملة على علم بجميع المعاملات وقرر أيها وصل أولاً. لتحقيق ذلك بدون طرف موثوق به ، يجب الإعلان عن المعاملات علنًا [1] ، ونحتاج إلى نظام للمشاركين للاتفاق على تاريخ واحد للترتيب الذي تم استلامها به. يحتاج المدفوع لأمره إلى إثبات أنه في وقت كل معاملة ، وافقت غالبية العقد على أنها كانت أول معاملة تم استلامها.

## خادم الطابع الزمني

يبدأ الحل الذي نقترحه بخادم طابع زمني. يعمل خادم الطابع الزمني عن طريق أخذ تجزئة لكتلة من العناصر ليتم ختمها بالطابع الزمني ونشر التجزئة على نطاق واسع ، كما هو الحال في صحيفة أو منشور يوزنت [2-5]. يثبت الطابع الزمني أن البيانات يجب أن تكون موجودة في ذلك الوقت ، من الواضح ، من أجل الوصول إلى التجزئة. يتضمن كل طابع زمني الطابع الزمني السابق في تجزئته ، مكونًا سلسلة ، مع كل طابع زمني إضافي يعزز ما قبله.

![](./timestamp-server.svg)

## إثبات العمل

لتنفيذ خادم طابع زمني موزع على أساس نظير إلى نظير ، سنحتاج إلى استخدام نظام إثبات عمل مشابه لنظام Adam Back's Hashcash [6] ، بدلاً من منشورات الصحف أو Usenet. يتضمن إثبات العمل مسحًا ضوئيًا لقيمة عند تجزئتها ، مثل SHA-256 ، تبدأ التجزئة بعدد من البتات الصفرية. متوسط ​​العمل المطلوب أسي في عدد البتات الصفرية المطلوبة ويمكن التحقق منه عن طريق تنفيذ تجزئة واحدة.

بالنسبة لشبكة الطوابع الزمنية الخاصة بنا ، نقوم بتنفيذ إثبات العمل عن طريق زيادة قيمة nonce في الكتلة حتى يتم العثور على قيمة تعطي تجزئة الكتلة بتات الصفر المطلوبة. بمجرد إنفاق جهد وحدة المعالجة المركزية لجعلها تفي بإثبات العمل ، لا يمكن تغيير الكتلة دون إعادة العمل. نظرًا لأن الكتل اللاحقة يتم تقييدها بعد ذلك ، فإن العمل على تغيير الكتلة سيشمل إعادة جميع الكتل التي تليها.

![](./proof-of-work.svg)

إثبات العمل يحل أيضًا مشكلة تحديد التمثيل في صنع قرار الأغلبية. إذا كانت الأغلبية تعتمد على عنوان IP واحد - صوت واحد ، فيمكن تخريبه من قبل أي شخص قادر على تخصيص العديد من عناوين IP. إثبات العمل هو في الأساس صوت واحد لوحدة المعالجة المركزية. يتم تمثيل قرار الأغلبية من خلال أطول سلسلة ، والتي لديها أكبر جهد لإثبات العمل المستثمر فيها. إذا تم التحكم في غالبية طاقة وحدة المعالجة المركزية بواسطة عقد صادقة ، فإن السلسلة الصادقة ستنمو بأسرع ما يمكن وتتفوق على أي سلاسل منافسة. لتعديل كتلة سابقة ، يجب على المهاجم إعادة إثبات عمل الكتلة وجميع الكتل التي تليها ثم اللحاق بعمل العقد الصادقة وتجاوزها. سوف نظهر لاحقًا أن احتمال قيام مهاجم أبطأ باللحاق بالركب يتضاءل بشكل كبير مع إضافة الكتل اللاحقة.

للتعويض عن زيادة سرعة الأجهزة والاهتمام المتفاوت بتشغيل العقد بمرور الوقت ، يتم تحديد صعوبة إثبات العمل من خلال متوسط ​​متحرك يستهدف متوسط ​​عدد الكتل في الساعة. إذا تم إنشاؤها بسرعة كبيرة ، تزداد الصعوبة.

## شبكة

فيما يلي خطوات تشغيل الشبكة:

1. يتم بث المعاملات الجديدة إلى جميع العقد.
2. كل عقدة تجمع المعاملات الجديدة في كتلة.
3. تعمل كل عقدة على إيجاد إثبات عمل صعب لكتلها.
4. عندما تجد العقدة إثباتًا للعمل ، فإنها تبث الكتلة إلى جميع العقد.
5. تقبل العقد الكتلة فقط إذا كانت جميع المعاملات فيها صحيحة ولم يتم إنفاقها بالفعل.
6. تعبر العقد عن قبولها للكتلة من خلال العمل على إنشاء الكتلة التالية في السلسلة ، باستخدام تجزئة الكتلة المقبولة مثل التجزئة السابقة.

تعتبر العقد دائمًا السلسلة الأطول هي السلسلة الصحيحة وستستمر في العمل على تمديدها. إذا بثت عقدتان إصدارات مختلفة من الكتلة التالية في وقت واحد ، فقد تتلقى بعض العقد واحدة أو أخرى أولاً. في هذه الحالة ، يعملون على أول فرع حصلوا عليه ، لكن يحفظون الفرع الآخر في حال أصبح أطول. سيتم كسر ربطة العنق عند العثور على إثبات العمل التالي ويصبح فرع واحد أطول ؛ سوف تتحول العقد التي كانت تعمل في الفرع الآخر إلى العقد الأطول.

لا تحتاج عمليات بث المعاملات الجديدة بالضرورة إلى الوصول إلى جميع العقد. طالما أنهم يصلون إلى العديد من العقد ، فسوف يدخلون في كتلة بعد فترة طويلة. عمليات البث المحظورة هي أيضًا متسامحة مع الرسائل المسقطة. إذا لم تستقبل العقدة كتلة ، فسوف تطلبها عندما تتلقى الكتلة التالية وتدرك أنها فقدت كتلة واحدة.`

## حافز

حسب الاصطلاح ، فإن المعاملة الأولى في الكتلة هي معاملة خاصة تبدأ عملة جديدة مملوكة من قبل منشئ الكتلة. يضيف هذا حافزًا للعقد لدعم الشبكة ، ويوفر طريقة لتوزيع العملات المعدنية في البداية ، نظرًا لعدم وجود سلطة مركزية لإصدارها. إن الإضافة الثابتة لكمية ثابتة من العملات المعدنية الجديدة مماثلة لعمال مناجم الذهب الذين ينفقون الموارد لإضافة الذهب للتداول. في حالتنا ، حان وقت وحدة المعالجة المركزية والكهرباء التي يتم إنفاقها.

يمكن أيضًا تمويل الحافز برسوم المعاملات. إذا كانت قيمة مخرجات المعاملة أقل من قيمة الإدخال ، يكون الفرق هو رسم المعاملة الذي يتم إضافته إلى القيمة التحفيزية للكتلة التي تحتوي على المعاملة. بمجرد دخول عدد محدد مسبقًا من العملات المعدنية للتداول ، يمكن أن ينتقل الحافز بالكامل إلى رسوم المعاملات ويكون خاليًا من التضخم تمامًا.

قد يساعد الحافز في تشجيع العقد على البقاء صادقة. إذا كان المهاجم الجشع قادرًا على تجميع المزيد من طاقة وحدة المعالجة المركزية أكثر من جميع العقد الصادقة ، فسيتعين عليه الاختيار بين استخدامها للاحتيال على الأشخاص عن طريق سرقة مدفوعاته ، أو استخدامها لإنشاء عملات معدنية جديدة. يجب أن يجد أنه من المربح أن يلعب وفقًا للقواعد ، مثل هذه القواعد التي تفضله بعملات معدنية جديدة أكثر من أي شخص آخر مجتمعين ، بدلاً من تقويض النظام وصلاحية ثروته الخاصة.

## استعادة مساحة القرص

بمجرد دفن آخر معاملة في عملة ما تحت كتل كافية ، يمكن التخلص من المعاملات المستنفدة قبل أن يتم توفير مساحة على القرص. لتسهيل ذلك دون كسر تجزئة الكتلة ، يتم تجزئة المعاملات في Merkle Tree [7] [2] [5] ، مع تضمين الجذر فقط في تجزئة الكتلة. يمكن بعد ذلك ضغط الكتل القديمة عن طريق قطع أغصان الشجرة. لا يلزم تخزين التجزئات الداخلية.

![](./reclaiming-disk-space.svg)

سيكون رأس الكتلة بدون معاملات حوالي 80 بايت. إذا افترضنا أن الكتل يتم إنشاؤها كل 10 دقائق ، 80 بايت * 6 * 24 * 365 = 4.2 ميجا بايت في السنة. مع بيع أنظمة الكمبيوتر عادةً بسعة 2 جيجابايت من ذاكرة الوصول العشوائي اعتبارًا من عام 2008 ، ويتنبأ قانون مور بالنمو الحالي البالغ 1.2 جيجابايت سنويًا ، لا ينبغي أن يكون التخزين مشكلة حتى إذا كان يجب الاحتفاظ برؤوس الكتلة في الذاكرة.

## التحقق من الدفع المبسط

من الممكن التحقق من المدفوعات بدون تشغيل عقدة شبكة كاملة. يحتاج المستخدم فقط إلى الاحتفاظ بنسخة من رؤوس الكتل لأطول سلسلة إثبات عمل ، والتي يمكنه الحصول عليها من خلال الاستعلام عن عقد الشبكة حتى يقتنع بأن لديه أطول سلسلة ، ويحصل على فرع Merkle الذي يربط المعاملة بالكتلة تم ختمها بختم زمني. لا يمكنه التحقق من المعاملة بنفسه ، ولكن من خلال ربطها بمكان في السلسلة ، يمكنه رؤية أن عقدة الشبكة قد قبلتها ، وتم إضافة الكتل بعد تأكيد قبول الشبكة لها.

![](./simplified-payment-verification.svg)

على هذا النحو ، يكون التحقق موثوقًا طالما أن العقد الصادقة تتحكم في الشبكة ، ولكنها تكون أكثر عرضة للخطر إذا تغلب المهاجم على الشبكة. بينما يمكن لعقد الشبكة التحقق من المعاملات بنفسها ، يمكن خداع الطريقة المبسطة من خلال المعاملات الملفقة للمهاجم طالما أن المهاجم يمكنه الاستمرار في التغلب على الشبكة. تتمثل إحدى إستراتيجيات الحماية من هذا في قبول التنبيهات من عُقد الشبكة عند اكتشافها كتلة غير صالحة ، مما يدفع برنامج المستخدم إلى تنزيل الكتلة الكاملة وتنبيه المعاملات لتأكيد عدم الاتساق. ربما لا تزال الشركات التي تتلقى مدفوعات متكررة ترغب في تشغيل العقد الخاصة بها لمزيد من الأمان المستقل والتحقق بشكل أسرع.

## ضم القيمة وتقسيمها

على الرغم من أنه سيكون من الممكن التعامل مع العملات المعدنية بشكل فردي ، إلا أنه سيكون من الصعب إجراء معاملة منفصلة لكل سنت في التحويل. للسماح بتقسيم القيمة ودمجها ، تحتوي المعاملات على مدخلات ومخرجات متعددة. عادةً ما يكون هناك إدخال واحد من معاملة سابقة أكبر أو مدخلات متعددة تجمع بين كميات أصغر ، ومخرجات على الأكثر: أحدهما للدفع ، والآخر يعيد التغيير ، إن وجد ، إلى المرسل.

![](./combining-splitting-value.svg)

وتجدر الإشارة إلى أن التوزيع الموسع ، حيث تعتمد المعاملة على العديد من المعاملات ، وتعتمد تلك المعاملات على العديد من المعاملات الأخرى ، لا يمثل مشكلة هنا. ليست هناك حاجة مطلقًا لاستخراج نسخة كاملة من سجل المعاملة.

## خصوصية

يحقق النموذج المصرفي التقليدي مستوى من الخصوصية من خلال تقييد الوصول إلى المعلومات إلى الأطراف المعنية والطرف الثالث الموثوق به. وضرورة الإعلان عن جميع المعاملات علنًا تحول دون هذه الطريقة ، ولكن لا يزال من الممكن الحفاظ على الخصوصية عن طريق كسر تدفق المعلومات في المكان: عن طريق الاحتفاظ بالمفاتيح العامة مجهولة. يمكن للجمهور أن يرى أن شخصًا ما يرسل مبلغًا إلى شخص آخر ، ولكن بدون معلومات تربط المعاملة بأي شخص. وهذا مشابه لمستوى المعلومات الصادرة عن البورصات ، حيث يكون وقت وحجم يتم نشر التداولات الفردية ، الشريط" ، على الملأ ، ولكن من دون الكشف عن هوية الأطراف ".

![](./privacy.svg)

كجدار حماية إضافي ، يجب استخدام زوج مفاتيح جديد لكل معاملة لمنعهم من الارتباط بمالك مشترك. لا يزال بعض الربط حتميًا مع المعاملات متعددة المدخلات ، والتي تكشف بالضرورة أن مدخلاتها مملوكة لنفس المالك. يكمن الخطر في أنه إذا تم الكشف عن مالك المفتاح ، فقد يكشف الربط عن معاملات أخرى تخص المالك نفسه.

## العمليات الحسابية

نحن نعتبر سيناريو مهاجم يحاول إنشاء سلسلة بديلة أسرع من السلسلة الصادقة. حتى إذا تم تحقيق ذلك ، فإنه لا يعرض النظام للتغييرات التعسفية ، مثل خلق قيمة من فراغ أو أخذ أموال لا تخص المهاجم أبدًا. لن تقبل العقد معاملة غير صالحة كدفعة ، ولن تقبل العقد الصادقة أبدًا كتلة تحتوي عليها. يمكن للمهاجم فقط محاولة تغيير إحدى معاملاته الخاصة لاستعادة الأموال التي أنفقها مؤخرًا.

يمكن وصف السباق بين السلسلة الصادقة وسلسلة المهاجمين بأنه مسيرة عشوائية ذات الحدين. حدث النجاح هو السلسلة الصادقة التي يتم تمديدها بواسطة كتلة واحدة ، مما يؤدي إلى زيادة تقدمها بمقدار +1 ، وحدث الفشل هو تمديد سلسلة المهاجم بمقدار كتلة واحدة ، مما يقلل الفجوة بمقدار -1.

إن احتمال أن يتمكن المهاجم من اللحاق بالركب من عجز معين مشابه لمشكلة تدمير Gambler. لنفترض أن مقامرًا ذا رصيد غير محدود يبدأ عند عجز ويلعب عددًا لا نهائيًا من المحاولات في محاولة للوصول إلى نقطة التعادل. يمكننا حساب احتمال وصوله إلى نقطة التعادل ، أو أن المهاجم سيلحق بالسلسلة الصادقة ، على النحو التالي [8]:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mtable columnalign="right center left" rowspacing="3pt" columnspacing="0 thickmathspace" displaystyle="true">
    <mtr>
      <mtd>
        <mstyle mathsize="1.2em">
          <mi>p</mi>
        </mstyle>
      </mtd>
      <mtd>
        <mi></mi>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mtext>&#xA0;probability an honest node finds the next block</mtext>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mstyle mathsize="1.2em">
          <mi>q</mi>
        </mstyle>
      </mtd>
      <mtd>
        <mi></mi>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mtext>&#xA0;probability the attacker finds the next block</mtext>
      </mtd>
    </mtr>
    <mtr>
      <mtd>
        <mstyle mathsize="1.2em">
          <msub>
            <mi>q</mi>
            <mi>z</mi>
          </msub>
        </mstyle>
      </mtd>
      <mtd>
        <mi></mi>
        <mo>=</mo>
      </mtd>
      <mtd>
        <mrow>
          <mtext>&#xA0;probability the attacker will ever catch up from&#xA0;</mtext>
          <mrow class="MJX-TeXAtom-ORD">
            <mi>z</mi>
          </mrow>
          <mtext>&#xA0;blocks behind</mtext>
        </mrow>
      </mtd>
    </mtr>
  </mtable>
</math>

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mstyle mathsize="1.2em">
    <msub>
      <mi>q</mi>
      <mi>z</mi>
    </msub>
    <mo>=</mo>
    <mrow>
      <mo>{</mo>
      <mtable rowspacing="4pt" columnspacing="1em">
        <mtr>
          <mtd>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext class="MJX-tex-mathit" mathvariant="italic">if</mtext>
            </mrow>
            <mspace width="thickmathspace" />
            <mi>p</mi>
            <mo>&#x2264;<!-- ≤ --></mo>
            <mi>q</mi>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mo stretchy="false">(</mo>
            <mi>q</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>p</mi>
            <msup>
              <mo stretchy="false">)</mo>
              <mi>z</mi>
            </msup>
          </mtd>
          <mtd>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext class="MJX-tex-mathit" mathvariant="italic">if</mtext>
            </mrow>
            <mspace width="thickmathspace" />
            <mi>p</mi>
            <mo>&gt;</mo>
            <mi>q</mi>
          </mtd>
        </mtr>
      </mtable>
      <mo>}</mo>
    </mrow>
  </mstyle>
</math>

بالنظر إلى افتراضنا
<math xmlns ="http://www.w3.org/1998/Math/MathML">
<mi> ف </mi>
<mo></mo>
<mi> ف </mi>
</math>، ينخفض ​​الاحتمال بشكل كبير مع زيادة عدد الكتل التي يجب على المهاجم اللحاق بها. مع الاحتمالات ضده ، إذا لم يندفع محظوظًا إلى الأمام في وقت مبكر ، فإن فرصه تصبح ضئيلة للغاية حيث يتخلف أكثر عن الركب .

نحن الآن نأخذ في الاعتبار المدة التي يحتاجها مستلم المعاملة الجديدة إلى الانتظار قبل أن يتأكد بشكل كافٍ من أن المرسل لا يمكنه تغيير المعاملة. نفترض أن المرسل مهاجم يريد أن يجعل المستلم يعتقد أنه دفع له لفترة من الوقت ، ثم يبدلها ليدفع لنفسه بعد مرور بعض الوقت. سيتم تنبيه المستلم عند حدوث ذلك ، لكن المرسل يأمل أن يكون الوقت قد فات.

يُنشئ جهاز الاستقبال زوج مفاتيح جديدًا ويعطي المفتاح العام للمرسل قبل التوقيع بوقت قصير. هذا يمنع المرسل من إعداد سلسلة من الكتل في وقت مبكر من خلال العمل عليها بشكل مستمر حتى يحالفه الحظ بما يكفي لتحقيق تقدم كافٍ ، ثم تنفيذ المعاملة في تلك اللحظة. بمجرد إرسال المعاملة ، يبدأ المرسل المخادع العمل سراً على سلسلة متوازية تحتوي على نسخة بديلة من معاملته.

ينتظر المستلم حتى تتم إضافة المعاملة إلى الكتلة و z
تم ربط الكتل بعدها. إنه لا يعرف مقدار التقدم الذي أحرزه المهاجم بالضبط ، ولكن بافتراض أن الكتل الصادقة استغرقت متوسط ​​الوقت المتوقع لكل كتلة ، فإن التقدم المحتمل للمهاجم سيكون توزيع بواسون بقيمة متوقعة:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mstyle mathsize="1.2em">
    <mi>&#x03BB;<!-- λ --></mi>
    <mo>=</mo>
    <mi>z</mi>
    <mfrac>
      <mi>q</mi>
      <mi>p</mi>
    </mfrac>
  </mstyle>
</math>

للحصول على احتمالية تمكن المهاجم من اللحاق بالركب الآن ، نقوم بضرب كثافة بواسون لكل مقدار تقدم كان يمكن أن يحرزه في احتمال أن يتمكن من اللحاق بالركب من تلك النقطة:

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mstyle mathsize="1.2em">
    <munderover>
      <mo>&#x2211;<!-- ∑ --></mo>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow class="MJX-TeXAtom-ORD">
        <mi mathvariant="normal">&#x221E;<!-- ∞ --></mi>
      </mrow>
    </munderover>
    <mfrac>
      <mrow>
        <msup>
          <mi>&#x03BB;<!-- λ --></mi>
          <mi>k</mi>
        </msup>
        <msup>
          <mi>e</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mo>&#x2212;<!-- − --></mo>
            <mi>&#x03BB;<!-- λ --></mi>
          </mrow>
        </msup>
      </mrow>
      <mrow>
        <mi>k</mi>
        <mo>!</mo>
      </mrow>
    </mfrac>
    <mo>&#x22C5;<!-- ⋅ --></mo>
    <mrow>
      <mo>{</mo>
      <mtable rowspacing="4pt" columnspacing="1em">
        <mtr>
          <mtd>
            <mo stretchy="false">(</mo>
            <mi>q</mi>
            <mrow class="MJX-TeXAtom-ORD">
              <mo>/</mo>
            </mrow>
            <mi>p</mi>
            <msup>
              <mo stretchy="false">)</mo>
              <mrow class="MJX-TeXAtom-ORD">
                <mo stretchy="false">(</mo>
                <mi>z</mi>
                <mo>&#x2212;<!-- − --></mo>
                <mi>k</mi>
                <mo stretchy="false">)</mo>
              </mrow>
            </msup>
          </mtd>
          <mtd>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext class="MJX-tex-mathit" mathvariant="italic">if</mtext>
            </mrow>
            <mspace width="thickmathspace" />
            <mi>k</mi>
            <mo>&#x2264;<!-- ≤ --></mo>
            <mi>z</mi>
          </mtd>
        </mtr>
        <mtr>
          <mtd>
            <mn>1</mn>
          </mtd>
          <mtd>
            <mrow class="MJX-TeXAtom-ORD">
              <mtext class="MJX-tex-mathit" mathvariant="italic">if</mtext>
            </mrow>
            <mspace width="thickmathspace" />
            <mi>k</mi>
            <mo>&gt;</mo>
            <mi>z</mi>
          </mtd>
        </mtr>
      </mtable>
      <mo>}</mo>
    </mrow>
  </mstyle>
</math>

إعادة الترتيب لتجنب جمع الذيل اللانهائي للتوزيع ...

<math xmlns="http://www.w3.org/1998/Math/MathML" display="block">
  <mstyle mathsize="1.2em">
    <mn>1</mn>
    <mo>&#x2212;<!-- − --></mo>
    <munderover>
      <mo>&#x2211;<!-- ∑ --></mo>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>k</mi>
        <mo>=</mo>
        <mn>0</mn>
      </mrow>
      <mrow class="MJX-TeXAtom-ORD">
        <mi>z</mi>
      </mrow>
    </munderover>
    <mfrac>
      <mrow>
        <msup>
          <mi>&#x03BB;<!-- λ --></mi>
          <mi>k</mi>
        </msup>
        <msup>
          <mi>e</mi>
          <mrow class="MJX-TeXAtom-ORD">
            <mo>&#x2212;<!-- − --></mo>
            <mi>&#x03BB;<!-- λ --></mi>
          </mrow>
        </msup>
      </mrow>
      <mrow>
        <mi>k</mi>
        <mo>!</mo>
      </mrow>
    </mfrac>
    <mrow>
      <mo>(</mo>
      <mrow>
        <mn>1</mn>
        <mo>&#x2212;<!-- − --></mo>
        <mo stretchy="false">(</mo>
        <mi>q</mi>
        <mrow class="MJX-TeXAtom-ORD">
          <mo>/</mo>
        </mrow>
        <mi>p</mi>
        <msup>
          <mo stretchy="false">)</mo>
          <mrow class="MJX-TeXAtom-ORD">
            <mo stretchy="false">(</mo>
            <mi>z</mi>
            <mo>&#x2212;<!-- − --></mo>
            <mi>k</mi>
            <mo stretchy="false">)</mo>
          </mrow>
        </msup>
      </mrow>
      <mo>)</mo>
    </mrow>
  </mstyle>
</math>

جاري التحويل إلى كود C ...

```c
#include 
double AttackerSuccessProbability(double q, int z)
{
	double p = 1.0 - q;
	double lambda = z * (q / p);
	double sum = 1.0;
	int i, k;
	for (k = 0; k <= z; k++)
	{
		double poisson = exp(-lambda);
		for (i = 1; i <= k; i++)
			poisson *= lambda / i;
		sum -= poisson * (1 - pow(q / p, z - k));
	}
	return sum;
}
```

عند تشغيل بعض النتائج ، يمكننا ملاحظة انخفاض الاحتمال أضعافًا مضاعفة مع z.

```
q=0.1
z=0    P=1.0000000
z=1    P=0.2045873
z=2    P=0.0509779
z=3    P=0.0131722
z=4    P=0.0034552
z=5    P=0.0009137
z=6    P=0.0002428
z=7    P=0.0000647
z=8    P=0.0000173
z=9    P=0.0000046
z=10   P=0.0000012

q=0.3
z=0    P=1.0000000
z=5    P=0.1773523
z=10   P=0.0416605
z=15   P=0.0101008
z=20   P=0.0024804
z=25   P=0.0006132
z=30   P=0.0001522
z=35   P=0.0000379
z=40   P=0.0000095
z=45   P=0.0000024
z=50   P=0.0000006
```

حل ل P أقل من 0.1٪ ...

```
P < 0.001
q=0.10   z=5
q=0.15   z=8
q=0.20   z=11
q=0.25   z=15
q=0.30   z=24
q=0.35   z=41
q=0.40   z=89
q=0.45   z=340
```

## خاتمة

لقد اقترحنا نظاما للمعاملات الإلكترونية دون الاعتماد على الثقة. بدأنا بالإطار المعتاد للعملات المعدنية المصنوعة من التوقيعات الرقمية ، والتي توفر تحكمًا قويًا في الملكية ، ولكنها غير مكتملة بدون وسيلة لمنع الإنفاق المزدوج. لحل هذه المشكلة ، اقترحنا شبكة نظير إلى نظير باستخدام إثبات العمل لتسجيل تاريخ عام للمعاملات التي تصبح سريعًا غير عملية من الناحية الحسابية للمهاجم لتغييرها إذا كانت العقد الصادقة تتحكم في غالبية طاقة وحدة المعالجة المركزية. الشبكة قوية في بساطتها غير المنظمة. تعمل العقد كلها في وقت واحد مع القليل من التنسيق. لا يلزم تحديد هويتهم ، نظرًا لأن الرسائل لا يتم توجيهها إلى أي مكان معين وتحتاج فقط إلى تسليمها على أساس بذل أفضل الجهود. يمكن للعقد مغادرة الشبكة وإعادة الانضمام إليها متى شاءت ، مع قبول سلسلة إثبات العمل كدليل على ما حدث أثناء ذهابهم. إنهم يصوتون بقوة وحدة المعالجة المركزية الخاصة بهم ، معربين عن قبولهم للكتل الصالحة من خلال العمل على تمديدها ورفض الكتل غير الصالحة من خلال رفض العمل عليها. يمكن تطبيق أي قواعد وحوافز مطلوبة من خلال آلية التوافق هذه.

## مراجع

1. W. Dai, ["b-money,"](https://nakamotoinstitute.org/b-money/) [http://www.weidai.com/bmoney.txt](http://www.weidai.com/bmoney.txt), 1998.
2. H. Massias, X.S. Avila, and J.-J. Quisquater, ["Design of a secure timestamping service with minimal trust requirements,"](https://nakamotoinstitute.org/secure-timestamping-service.pdf) In 20th Symposium on Information Theory in the Benelux, May 1999.
3. S. Haber, W.S. Stornetta, ["How to time-stamp a digital document,"](https://nakamotoinstitute.org/time-stamp-digital-document.pdf) In Journal of Cryptology, vol 3, no 2, pages 99-111, 1991.
4. D. Bayer, S. Haber, W.S. Stornetta, ["Improving the efficiency and reliability of digital time-stamping,"](https://nakamotoinstitute.org/improving-time-stamping.pdf) In Sequences II: Methods in Communication, Security and Computer Science, pages 329-334, 1993.
5. S. Haber, W.S. Stornetta, ["Secure names for bit-strings,"](https://nakamotoinstitute.org/secure-names-bit-strings.pdf) In Proceedings of the 4th ACM Conference on Computer and Communications Security, pages 28-35, April 1997.
6. A. Back, ["Hashcash - a denial of service counter-measure,"](https://nakamotoinstitute.org/hashcash.pdf) ][http://www.hashcash.org/papers/hashcash.pdf](http://www.hashcash.org/papers/hashcash.pdf), 2002.
7. R.C. Merkle, ["Protocols for public key cryptosystems,"](https://nakamotoinstitute.org/public-key-cryptosystems.pdf) In Proc. 1980 Symposium on Security and Privacy, IEEE Computer Society, pages 122-133, April 1980.
8. W. Feller, ["An introduction to probability theory and its applications,"](https://nakamotoinstitute.org/introduction-probability-theory-vol-i.pdf) 1957.